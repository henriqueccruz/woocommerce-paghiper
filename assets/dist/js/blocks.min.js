(function(){var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$1 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
function A(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z && a[z] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C = Object.assign, D = {};
function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
E.prototype.isReactComponent = {};
E.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E.prototype;
function G(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D;
  this.updater = e || B;
}
var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = true;
var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
function M(a, b, e) {
  var d, c = {}, k2 = null, h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g) c.children = e;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++) f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
  return { $$typeof: l$1, type: a, key: k2, ref: h, props: c, _owner: K.current };
}
function N(a, b) {
  return { $$typeof: l$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function O(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$1;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var P = /\/+/g;
function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R(a, b, e, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h = false;
  if (null === a) h = true;
  else switch (k2) {
    case "string":
    case "number":
      h = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$1:
        case n$1:
          h = true;
      }
  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
    return a2;
  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I(a)) for (var g = 0; g < a.length; g++) {
    k2 = a[g];
    var f2 = d + Q(k2, g);
    h += R(k2, b, e, f2, c);
  }
  else if (f2 = A(a), "function" === typeof f2) for (a = f2.call(a), g = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d + Q(k2, g++), h += R(k2, b, e, f2, c);
  else if ("object" === k2) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}
function S(a, b, e) {
  if (null == a) return a;
  var d = [], c = 0;
  R(a, d, "", "", function(a2) {
    return b.call(e, a2, c++);
  });
  return d;
}
function T(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
    }, function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
function X() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S, forEach: function(a, b, e) {
  S(a, function() {
    b.apply(this, arguments);
  }, e);
}, count: function(a) {
  var b = 0;
  S(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return S(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E;
react_production_min.Fragment = p$1;
react_production_min.Profiler = r;
react_production_min.PureComponent = G;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
react_production_min.act = X;
react_production_min.cloneElement = function(a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C({}, a.props), c = a.key, k2 = a.ref, h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k2 = b.ref, h = K.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
    for (f2 in b) J.call(b, f2) && !L.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d.children = e;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g[m2] = arguments[m2 + 2];
    d.children = g;
  }
  return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d, _owner: h };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M;
react_production_min.createFactory = function(a) {
  var b = M.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v, render: a };
};
react_production_min.isValidElement = O;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
};
react_production_min.startTransition = function(a) {
  var b = V.transition;
  V.transition = {};
  try {
    a();
  } finally {
    V.transition = b;
  }
};
react_production_min.unstable_act = X;
react_production_min.useCallback = function(a, b) {
  return U.current.useCallback(a, b);
};
react_production_min.useContext = function(a) {
  return U.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b) {
  return U.current.useEffect(a, b);
};
react_production_min.useId = function() {
  return U.current.useId();
};
react_production_min.useImperativeHandle = function(a, b, e) {
  return U.current.useImperativeHandle(a, b, e);
};
react_production_min.useInsertionEffect = function(a, b) {
  return U.current.useInsertionEffect(a, b);
};
react_production_min.useLayoutEffect = function(a, b) {
  return U.current.useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return U.current.useMemo(a, b);
};
react_production_min.useReducer = function(a, b, e) {
  return U.current.useReducer(a, b, e);
};
react_production_min.useRef = function(a) {
  return U.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b, e) {
  return U.current.useSyncExternalStore(a, b, e);
};
react_production_min.useTransition = function() {
  return U.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;
PRECEDENCE = {
  "(": 9,
  "!": 8,
  "*": 7,
  "/": 7,
  "%": 7,
  "+": 6,
  "-": 6,
  "<": 5,
  "<=": 5,
  ">": 5,
  ">=": 5,
  "==": 4,
  "!=": 4,
  "&&": 3,
  "||": 2,
  "?": 1,
  "?:": 1
};
OPENERS = ["(", "?"];
TERMINATORS = {
  ")": ["("],
  ":": ["?", "?:"]
};
PATTERN = /<=|>=|==|!=|&&|\|\||\?:|\(|!|\*|\/|%|\+|-|<|>|\?|\)|:/;
function postfix(expression) {
  var terms = [], stack = [], match, operator, term, element;
  while (match = expression.match(PATTERN)) {
    operator = match[0];
    term = expression.substr(0, match.index).trim();
    if (term) {
      terms.push(term);
    }
    while (element = stack.pop()) {
      if (TERMINATORS[operator]) {
        if (TERMINATORS[operator][0] === element) {
          operator = TERMINATORS[operator][1] || operator;
          break;
        }
      } else if (OPENERS.indexOf(element) >= 0 || PRECEDENCE[element] < PRECEDENCE[operator]) {
        stack.push(element);
        break;
      }
      terms.push(element);
    }
    if (!TERMINATORS[operator]) {
      stack.push(operator);
    }
    expression = expression.substr(match.index + operator.length);
  }
  expression = expression.trim();
  if (expression) {
    terms.push(expression);
  }
  return terms.concat(stack.reverse());
}
var OPERATORS = {
  "!": function(a) {
    return !a;
  },
  "*": function(a, b) {
    return a * b;
  },
  "/": function(a, b) {
    return a / b;
  },
  "%": function(a, b) {
    return a % b;
  },
  "+": function(a, b) {
    return a + b;
  },
  "-": function(a, b) {
    return a - b;
  },
  "<": function(a, b) {
    return a < b;
  },
  "<=": function(a, b) {
    return a <= b;
  },
  ">": function(a, b) {
    return a > b;
  },
  ">=": function(a, b) {
    return a >= b;
  },
  "==": function(a, b) {
    return a === b;
  },
  "!=": function(a, b) {
    return a !== b;
  },
  "&&": function(a, b) {
    return a && b;
  },
  "||": function(a, b) {
    return a || b;
  },
  "?:": function(a, b, c) {
    if (a) {
      throw b;
    }
    return c;
  }
};
function evaluate(postfix2, variables) {
  var stack = [], i, j, args, getOperatorResult, term, value;
  for (i = 0; i < postfix2.length; i++) {
    term = postfix2[i];
    getOperatorResult = OPERATORS[term];
    if (getOperatorResult) {
      j = getOperatorResult.length;
      args = Array(j);
      while (j--) {
        args[j] = stack.pop();
      }
      try {
        value = getOperatorResult.apply(null, args);
      } catch (earlyReturn) {
        return earlyReturn;
      }
    } else if (variables.hasOwnProperty(term)) {
      value = variables[term];
    } else {
      value = +term;
    }
    stack.push(value);
  }
  return stack[0];
}
function compile(expression) {
  var terms = postfix(expression);
  return function(variables) {
    return evaluate(terms, variables);
  };
}
function pluralForms(expression) {
  var evaluate2 = compile(expression);
  return function(n2) {
    return +evaluate2({ n: n2 });
  };
}
var DEFAULT_OPTIONS = {
  contextDelimiter: "",
  onMissingKey: null
};
function getPluralExpression(pf) {
  var parts, i, part;
  parts = pf.split(";");
  for (i = 0; i < parts.length; i++) {
    part = parts[i].trim();
    if (part.indexOf("plural=") === 0) {
      return part.substr(7);
    }
  }
}
function Tannin(data, options) {
  var key;
  this.data = data;
  this.pluralForms = {};
  this.options = {};
  for (key in DEFAULT_OPTIONS) {
    this.options[key] = options !== void 0 && key in options ? options[key] : DEFAULT_OPTIONS[key];
  }
}
Tannin.prototype.getPluralForm = function(domain, n2) {
  var getPluralForm = this.pluralForms[domain], config, plural, pf;
  if (!getPluralForm) {
    config = this.data[domain][""];
    pf = config["Plural-Forms"] || config["plural-forms"] || // Ignore reason: As known, there's no way to document the empty
    // string property on a key to guarantee this as metadata.
    // @ts-ignore
    config.plural_forms;
    if (typeof pf !== "function") {
      plural = getPluralExpression(
        config["Plural-Forms"] || config["plural-forms"] || // Ignore reason: As known, there's no way to document the empty
        // string property on a key to guarantee this as metadata.
        // @ts-ignore
        config.plural_forms
      );
      pf = pluralForms(plural);
    }
    getPluralForm = this.pluralForms[domain] = pf;
  }
  return getPluralForm(n2);
};
Tannin.prototype.dcnpgettext = function(domain, context, singular, plural, n2) {
  var index, key, entry;
  if (n2 === void 0) {
    index = 0;
  } else {
    index = this.getPluralForm(domain, n2);
  }
  key = singular;
  if (context) {
    key = context + this.options.contextDelimiter + singular;
  }
  entry = this.data[domain][key];
  if (entry && entry[index]) {
    return entry[index];
  }
  if (this.options.onMissingKey) {
    this.options.onMissingKey(singular, domain);
  }
  return index === 0 ? singular : plural;
};
const DEFAULT_LOCALE_DATA = {
  "": {
    plural_forms(n2) {
      return n2 === 1 ? 0 : 1;
    }
  }
};
const I18N_HOOK_REGEXP = /^i18n\.(n?gettext|has_translation)(_|$)/;
const createI18n = (initialData, initialDomain, hooks) => {
  const tannin = new Tannin({});
  const listeners = /* @__PURE__ */ new Set();
  const notifyListeners = () => {
    listeners.forEach((listener) => listener());
  };
  const subscribe = (callback) => {
    listeners.add(callback);
    return () => listeners.delete(callback);
  };
  const getLocaleData = (domain = "default") => tannin.data[domain];
  const doSetLocaleData = (data, domain = "default") => {
    var _a;
    tannin.data[domain] = {
      ...tannin.data[domain],
      ...data
    };
    tannin.data[domain][""] = {
      ...DEFAULT_LOCALE_DATA[""],
      ...(_a = tannin.data[domain]) == null ? void 0 : _a[""]
    };
    delete tannin.pluralForms[domain];
  };
  const setLocaleData = (data, domain) => {
    doSetLocaleData(data, domain);
    notifyListeners();
  };
  const addLocaleData = (data, domain = "default") => {
    var _a;
    tannin.data[domain] = {
      ...tannin.data[domain],
      ...data,
      // Populate default domain configuration (supported locale date which omits
      // a plural forms expression).
      "": {
        ...DEFAULT_LOCALE_DATA[""],
        ...(_a = tannin.data[domain]) == null ? void 0 : _a[""],
        ...data == null ? void 0 : data[""]
      }
    };
    delete tannin.pluralForms[domain];
    notifyListeners();
  };
  const resetLocaleData = (data, domain) => {
    tannin.data = {};
    tannin.pluralForms = {};
    setLocaleData(data, domain);
  };
  const dcnpgettext = (domain = "default", context, single, plural, number) => {
    if (!tannin.data[domain]) {
      doSetLocaleData(void 0, domain);
    }
    return tannin.dcnpgettext(domain, context, single, plural, number);
  };
  const getFilterDomain = (domain) => domain || "default";
  const __2 = (text, domain) => {
    let translation = dcnpgettext(domain, void 0, text);
    if (!hooks) {
      return translation;
    }
    translation = hooks.applyFilters("i18n.gettext", translation, text, domain);
    return hooks.applyFilters("i18n.gettext_" + getFilterDomain(domain), translation, text, domain);
  };
  const _x = (text, context, domain) => {
    let translation = dcnpgettext(domain, context, text);
    if (!hooks) {
      return translation;
    }
    translation = hooks.applyFilters("i18n.gettext_with_context", translation, text, context, domain);
    return hooks.applyFilters("i18n.gettext_with_context_" + getFilterDomain(domain), translation, text, context, domain);
  };
  const _n = (single, plural, number, domain) => {
    let translation = dcnpgettext(domain, void 0, single, plural, number);
    if (!hooks) {
      return translation;
    }
    translation = hooks.applyFilters("i18n.ngettext", translation, single, plural, number, domain);
    return hooks.applyFilters("i18n.ngettext_" + getFilterDomain(domain), translation, single, plural, number, domain);
  };
  const _nx = (single, plural, number, context, domain) => {
    let translation = dcnpgettext(domain, context, single, plural, number);
    if (!hooks) {
      return translation;
    }
    translation = hooks.applyFilters("i18n.ngettext_with_context", translation, single, plural, number, context, domain);
    return hooks.applyFilters("i18n.ngettext_with_context_" + getFilterDomain(domain), translation, single, plural, number, context, domain);
  };
  const isRTL = () => {
    return "rtl" === _x("ltr", "text direction");
  };
  const hasTranslation = (single, context, domain) => {
    var _a, _b;
    const key = context ? context + "" + single : single;
    let result = !!((_b = (_a = tannin.data) == null ? void 0 : _a[domain !== null && domain !== void 0 ? domain : "default"]) == null ? void 0 : _b[key]);
    if (hooks) {
      result = hooks.applyFilters("i18n.has_translation", result, single, context, domain);
      result = hooks.applyFilters("i18n.has_translation_" + getFilterDomain(domain), result, single, context, domain);
    }
    return result;
  };
  if (hooks) {
    const onHookAddedOrRemoved = (hookName) => {
      if (I18N_HOOK_REGEXP.test(hookName)) {
        notifyListeners();
      }
    };
    hooks.addAction("hookAdded", "core/i18n", onHookAddedOrRemoved);
    hooks.addAction("hookRemoved", "core/i18n", onHookAddedOrRemoved);
  }
  return {
    getLocaleData,
    setLocaleData,
    addLocaleData,
    resetLocaleData,
    subscribe,
    __: __2,
    _x,
    _n,
    _nx,
    isRTL,
    hasTranslation
  };
};
function validateNamespace(namespace) {
  if ("string" !== typeof namespace || "" === namespace) {
    console.error("The namespace must be a non-empty string.");
    return false;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9_.\-\/]*$/.test(namespace)) {
    console.error("The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.");
    return false;
  }
  return true;
}
function validateHookName(hookName) {
  if ("string" !== typeof hookName || "" === hookName) {
    console.error("The hook name must be a non-empty string.");
    return false;
  }
  if (/^__/.test(hookName)) {
    console.error("The hook name cannot begin with `__`.");
    return false;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {
    console.error("The hook name can only contain numbers, letters, dashes, periods and underscores.");
    return false;
  }
  return true;
}
function createAddHook(hooks, storeKey) {
  return function addHook(hookName, namespace, callback, priority = 10) {
    const hooksStore = hooks[storeKey];
    if (!validateHookName(hookName)) {
      return;
    }
    if (!validateNamespace(namespace)) {
      return;
    }
    if ("function" !== typeof callback) {
      console.error("The hook callback must be a function.");
      return;
    }
    if ("number" !== typeof priority) {
      console.error("If specified, the hook priority must be a number.");
      return;
    }
    const handler = {
      callback,
      priority,
      namespace
    };
    if (hooksStore[hookName]) {
      const handlers = hooksStore[hookName].handlers;
      let i;
      for (i = handlers.length; i > 0; i--) {
        if (priority >= handlers[i - 1].priority) {
          break;
        }
      }
      if (i === handlers.length) {
        handlers[i] = handler;
      } else {
        handlers.splice(i, 0, handler);
      }
      hooksStore.__current.forEach((hookInfo) => {
        if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
          hookInfo.currentIndex++;
        }
      });
    } else {
      hooksStore[hookName] = {
        handlers: [handler],
        runs: 0
      };
    }
    if (hookName !== "hookAdded") {
      hooks.doAction("hookAdded", hookName, namespace, callback, priority);
    }
  };
}
function createRemoveHook(hooks, storeKey, removeAll = false) {
  return function removeHook(hookName, namespace) {
    const hooksStore = hooks[storeKey];
    if (!validateHookName(hookName)) {
      return;
    }
    if (!removeAll && !validateNamespace(namespace)) {
      return;
    }
    if (!hooksStore[hookName]) {
      return 0;
    }
    let handlersRemoved = 0;
    if (removeAll) {
      handlersRemoved = hooksStore[hookName].handlers.length;
      hooksStore[hookName] = {
        runs: hooksStore[hookName].runs,
        handlers: []
      };
    } else {
      const handlers = hooksStore[hookName].handlers;
      for (let i = handlers.length - 1; i >= 0; i--) {
        if (handlers[i].namespace === namespace) {
          handlers.splice(i, 1);
          handlersRemoved++;
          hooksStore.__current.forEach((hookInfo) => {
            if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
              hookInfo.currentIndex--;
            }
          });
        }
      }
    }
    if (hookName !== "hookRemoved") {
      hooks.doAction("hookRemoved", hookName, namespace);
    }
    return handlersRemoved;
  };
}
function createHasHook(hooks, storeKey) {
  return function hasHook(hookName, namespace) {
    const hooksStore = hooks[storeKey];
    if ("undefined" !== typeof namespace) {
      return hookName in hooksStore && hooksStore[hookName].handlers.some((hook) => hook.namespace === namespace);
    }
    return hookName in hooksStore;
  };
}
function createRunHook(hooks, storeKey, returnFirstArg, async) {
  return function runHook(hookName, ...args) {
    const hooksStore = hooks[storeKey];
    if (!hooksStore[hookName]) {
      hooksStore[hookName] = {
        handlers: [],
        runs: 0
      };
    }
    hooksStore[hookName].runs++;
    const handlers = hooksStore[hookName].handlers;
    if (!handlers || !handlers.length) {
      return returnFirstArg ? args[0] : void 0;
    }
    const hookInfo = {
      name: hookName,
      currentIndex: 0
    };
    async function asyncRunner() {
      try {
        hooksStore.__current.add(hookInfo);
        let result = returnFirstArg ? args[0] : void 0;
        while (hookInfo.currentIndex < handlers.length) {
          const handler = handlers[hookInfo.currentIndex];
          result = await handler.callback.apply(null, args);
          if (returnFirstArg) {
            args[0] = result;
          }
          hookInfo.currentIndex++;
        }
        return returnFirstArg ? result : void 0;
      } finally {
        hooksStore.__current.delete(hookInfo);
      }
    }
    function syncRunner() {
      try {
        hooksStore.__current.add(hookInfo);
        let result = returnFirstArg ? args[0] : void 0;
        while (hookInfo.currentIndex < handlers.length) {
          const handler = handlers[hookInfo.currentIndex];
          result = handler.callback.apply(null, args);
          if (returnFirstArg) {
            args[0] = result;
          }
          hookInfo.currentIndex++;
        }
        return returnFirstArg ? result : void 0;
      } finally {
        hooksStore.__current.delete(hookInfo);
      }
    }
    return (async ? asyncRunner : syncRunner)();
  };
}
function createCurrentHook(hooks, storeKey) {
  return function currentHook() {
    var _a;
    var _currentArray$at$name;
    const hooksStore = hooks[storeKey];
    const currentArray = Array.from(hooksStore.__current);
    return (_currentArray$at$name = (_a = currentArray.at(-1)) == null ? void 0 : _a.name) !== null && _currentArray$at$name !== void 0 ? _currentArray$at$name : null;
  };
}
function createDoingHook(hooks, storeKey) {
  return function doingHook(hookName) {
    const hooksStore = hooks[storeKey];
    if ("undefined" === typeof hookName) {
      return hooksStore.__current.size > 0;
    }
    return Array.from(hooksStore.__current).some((hook) => hook.name === hookName);
  };
}
function createDidHook(hooks, storeKey) {
  return function didHook(hookName) {
    const hooksStore = hooks[storeKey];
    if (!validateHookName(hookName)) {
      return;
    }
    return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;
  };
}
class _Hooks {
  constructor() {
    this.actions = /* @__PURE__ */ Object.create(null);
    this.actions.__current = /* @__PURE__ */ new Set();
    this.filters = /* @__PURE__ */ Object.create(null);
    this.filters.__current = /* @__PURE__ */ new Set();
    this.addAction = createAddHook(this, "actions");
    this.addFilter = createAddHook(this, "filters");
    this.removeAction = createRemoveHook(this, "actions");
    this.removeFilter = createRemoveHook(this, "filters");
    this.hasAction = createHasHook(this, "actions");
    this.hasFilter = createHasHook(this, "filters");
    this.removeAllActions = createRemoveHook(this, "actions", true);
    this.removeAllFilters = createRemoveHook(this, "filters", true);
    this.doAction = createRunHook(this, "actions", false, false);
    this.doActionAsync = createRunHook(this, "actions", false, true);
    this.applyFilters = createRunHook(this, "filters", true, false);
    this.applyFiltersAsync = createRunHook(this, "filters", true, true);
    this.currentAction = createCurrentHook(this, "actions");
    this.currentFilter = createCurrentHook(this, "filters");
    this.doingAction = createDoingHook(this, "actions");
    this.doingFilter = createDoingHook(this, "filters");
    this.didAction = createDidHook(this, "actions");
    this.didFilter = createDidHook(this, "filters");
  }
}
function createHooks() {
  return new _Hooks();
}
const defaultHooks = createHooks();
const {
  addAction,
  addFilter,
  removeAction,
  removeFilter,
  hasAction,
  hasFilter,
  removeAllActions,
  removeAllFilters,
  doAction,
  doActionAsync,
  applyFilters,
  applyFiltersAsync,
  currentAction,
  currentFilter,
  doingAction,
  doingFilter,
  didAction,
  didFilter,
  actions,
  filters
} = defaultHooks;
const i18n = createI18n(void 0, void 0, defaultHooks);
i18n.getLocaleData.bind(i18n);
i18n.setLocaleData.bind(i18n);
i18n.resetLocaleData.bind(i18n);
i18n.subscribe.bind(i18n);
const __$1 = i18n.__.bind(i18n);
i18n._x.bind(i18n);
i18n._n.bind(i18n);
i18n._nx.bind(i18n);
i18n.isRTL.bind(i18n);
i18n.hasTranslation.bind(i18n);
const getComputedStyle = (selector, property, defaultValue) => {
  let elementStyle = {};
  if (typeof document === "object" && typeof document.querySelector === "function" && typeof window.getComputedStyle === "function") {
    const element = document.querySelector(selector);
    if (element) {
      elementStyle = window.getComputedStyle(element);
    }
  }
  return elementStyle[property] || defaultValue;
};
const elementOptions = {
  style: {
    base: {
      iconColor: "#666EE8",
      color: "#31325F",
      fontSize: getComputedStyle(
        ".wc-block-checkout",
        "fontSize",
        "16px"
      ),
      lineHeight: 1.375,
      // With a font-size of 16px, line-height will be 22px.
      "::placeholder": {
        color: "#fff"
      }
    }
  },
  classes: {
    focus: "focused",
    empty: "empty",
    invalid: "has-error"
  }
};
const useElementOptions = (overloadedOptions) => {
  const [isActive, setIsActive] = reactExports.useState(false);
  const [isFocus, setIsFocus] = reactExports.useState(false);
  const [options, setOptions] = reactExports.useState({
    ...elementOptions,
    ...overloadedOptions
  });
  const [error, setError] = reactExports.useState("");
  reactExports.useEffect(() => {
    const color = isActive ? "#CFD7E0" : "#fff";
    setOptions((prevOptions) => {
      let showIcon;
      if (prevOptions.showIcon === false) {
        showIcon = { showIcon: false };
      } else if (typeof prevOptions.showIcon !== "undefined") {
        showIcon = { showIcon: isActive };
      } else {
        showIcon = {};
      }
      return {
        ...prevOptions,
        style: {
          ...prevOptions.style,
          base: {
            ...prevOptions.style.base,
            "::placeholder": {
              color
            }
          }
        },
        ...showIcon
      };
    });
  }, [isActive]);
  const onActive = reactExports.useCallback(
    (isEmpty, isFocus2) => {
      if (!isEmpty) {
        setIsActive(true);
      } else {
        setIsActive((prevActive) => !prevActive);
      }
      if (isFocus2) {
        setIsFocus(true);
      } else {
        setIsFocus(false);
      }
    },
    [setIsActive, setIsFocus]
  );
  return { options, isActive, isFocus, onActive, error, setError };
};
var dist = {};
var cnh = {};
var ValidationBRError$1 = {};
Object.defineProperty(ValidationBRError$1, "__esModule", { value: true });
class ValidationBRError extends Error {
}
ValidationBRError.INVALID_DV = new ValidationBRError("Dígito verificador inválido");
ValidationBRError.EMPTY_VALUE = new ValidationBRError("Valor não preenchido");
ValidationBRError.MAX_LEN_EXCEDEED = new ValidationBRError("Número de caracteres excedido");
ValidationBRError.REPEATED_SEQUENCE = new ValidationBRError("Sequência de números repetidos não permitida");
ValidationBRError$1.default = ValidationBRError;
var utils = {};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(utils, "__esModule", { value: true });
utils.sumToDV = sumToDV;
utils.checkRepeatedSequence = checkRepeatedSequence;
utils.sumElementsByMultipliers = sumElementsByMultipliers;
utils.fakeNumber = fakeNumber;
utils.clearValue = clearValue;
utils.insertAtPosition = insertAtPosition;
utils.removeFromPosition = removeFromPosition;
utils.applyMask = applyMask;
utils.randomLetter = randomLetter;
const ValidationBRError_1$1 = __importDefault$1(ValidationBRError$1);
function sumToDV(sum) {
  return sum % 11 < 2 ? 0 : 11 - sum % 11;
}
function checkRepeatedSequence(value) {
  return [...value].every((digit) => digit === value[0]);
}
function sumElementsByMultipliers(value, multiplier) {
  return multiplier.reduce((accu, curr, i) => accu + curr * Number(value[i]), 0);
}
function fakeNumber(length, forceLength = false, isAlpha = false) {
  let value;
  if (isAlpha)
    value = Math.round(Math.random() * 36 ** length).toString(36).toLocaleUpperCase();
  else
    value = Math.floor(Math.random() * 10 ** length).toString();
  if (forceLength)
    return String(value).padStart(length, "0");
  return String(value);
}
function clearValue(value, length = null, options) {
  let clearedValue = String(value).replace(/([/.-]+)/gi, "");
  if (options) {
    const shouldRejectEmpty = options.rejectEmpty === true && clearedValue.length === 0;
    if (shouldRejectEmpty) {
      throw ValidationBRError_1$1.default.EMPTY_VALUE;
    }
    const shouldRejectHigherLength = options.rejectHigherLength === true && length && clearedValue.length > length;
    if (shouldRejectHigherLength) {
      throw ValidationBRError_1$1.default.MAX_LEN_EXCEDEED;
    }
    const shouldRejectEqualSequence = options.rejectEqualSequence === true && length;
    if (shouldRejectEqualSequence) {
      if (checkRepeatedSequence(clearedValue))
        throw ValidationBRError_1$1.default.REPEATED_SEQUENCE;
    }
    if (length && options.fillZerosAtLeft)
      clearedValue = clearedValue.padStart(length, "0");
    if (length && options.trimAtRight)
      clearedValue = clearedValue.substring(0, length);
  }
  return clearedValue;
}
function insertAtPosition(value, insertValue, position) {
  return `${value.substring(0, position)}${insertValue}${value.substring(position)}`;
}
function removeFromPosition(value, startPosition, endPosition) {
  return [value.slice(0, startPosition), value.slice(endPosition)].join("");
}
function applyMask(value, mask2) {
  const maskLen = clearValue(mask2).length;
  let masked = clearValue(value, maskLen, { fillZerosAtLeft: true, trimAtRight: true });
  const specialChars = ["/", "-", ".", "(", ")", " "];
  for (let position = 0; position < mask2.length; position += 1) {
    const current = mask2[position];
    if (specialChars.includes(current))
      masked = insertAtPosition(masked, current, position);
  }
  return masked;
}
function randomLetter() {
  const idx = Math.floor(1 + Math.random() * 26);
  return String.fromCharCode(idx + 64);
}
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fake = exports.mask = exports.validate = exports.validateOrFail = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const cnh2 = (0, utils_12.clearValue)(value, 9, {
      trimAtRight: true,
      rejectEmpty: true
    });
    const sum1 = (0, utils_12.sumElementsByMultipliers)(cnh2.substring(0, 9), [2, 3, 4, 5, 6, 7, 8, 9, 10]);
    const dv1 = (0, utils_12.sumToDV)(sum1);
    const sum2 = (0, utils_12.sumElementsByMultipliers)(cnh2.substring(0, 9) + dv1, [3, 4, 5, 6, 7, 8, 9, 10, 11, 2]);
    const dv22 = (0, utils_12.sumToDV)(sum2);
    return `${dv1}${dv22}`;
  };
  exports.dv = dv2;
  const validateOrFail2 = (value) => {
    const cnh2 = (0, utils_12.clearValue)(value, 11, {
      fillZerosAtLeft: true,
      rejectEmpty: true,
      rejectHigherLength: true,
      rejectEqualSequence: true
    });
    if ((0, exports.dv)(cnh2) !== cnh2.substring(9, 11)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "000000000-00");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const value = (0, utils_12.fakeNumber)(9, true);
    const cnh2 = `${value}${(0, exports.dv)(value)}`;
    if (withMask)
      return (0, exports.mask)(cnh2);
    return cnh2;
  };
  exports.fake = fake2;
  exports.default = exports.validate;
})(cnh);
var cnpj = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cnpj, "__esModule", { value: true });
cnpj.dv = dv;
cnpj.mask = mask;
cnpj.fake = fake;
cnpj.validateOrFail = validateOrFail;
cnpj.validate = validate;
const ValidationBRError_1 = __importDefault(ValidationBRError$1);
const utils_1 = utils;
function dv(value) {
  const cnpj2 = (0, utils_1.clearValue)(value, 12, {
    trimAtRight: true,
    rejectEmpty: true
  });
  const dv1Factors = [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
  const dv1 = sumToDvWithAlpha(cnpj2.substring(0, 12), dv1Factors);
  const dv2Factors = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
  const dv2 = sumToDvWithAlpha(cnpj2.substring(0, 12) + dv1, dv2Factors);
  return `${dv1}${dv2}`;
}
function mask(value) {
  return (0, utils_1.applyMask)(value, "00.000.000/0000-00");
}
function fake(input = false) {
  const options = typeof input === "boolean" ? { withMask: input, alphanumeric: true } : { withMask: false, alphanumeric: true, ...input };
  const num = (0, utils_1.fakeNumber)(12, true, options.alphanumeric);
  const cnpj2 = `${num}${dv(num)}`;
  if (options.withMask)
    return mask(cnpj2);
  return cnpj2;
}
function validateOrFail(value) {
  const cnpj2 = (0, utils_1.clearValue)(value, 14, {
    fillZerosAtLeft: false,
    rejectEmpty: true,
    rejectHigherLength: true,
    rejectEqualSequence: true
  });
  if (dv(cnpj2) !== cnpj2.substring(12, 14)) {
    throw ValidationBRError_1.default.INVALID_DV;
  }
  return true;
}
function validate(value) {
  try {
    return validateOrFail(value);
  } catch (error) {
    return false;
  }
}
cnpj.default = validate;
function asciiTableConverter(character) {
  if (/^\d$/.test(character))
    return +character;
  const ascii = character.toLocaleUpperCase().charCodeAt(0) - 48;
  return ascii;
}
function sumToDvWithAlpha(value, multiplier) {
  const sum = [...value].map((character) => asciiTableConverter(character)).reduce((sum2, asciiChar, index) => sum2 + asciiChar * multiplier[index], 0);
  return (0, utils_1.sumToDV)(sum);
}
var cpf = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const cpf2 = (0, utils_12.clearValue)(value, 9, {
      trimAtRight: true,
      rejectEmpty: true
    });
    const sum1 = (0, utils_12.sumElementsByMultipliers)(cpf2, [10, 9, 8, 7, 6, 5, 4, 3, 2]);
    const dv1 = (0, utils_12.sumToDV)(sum1);
    const sum2 = (0, utils_12.sumElementsByMultipliers)(cpf2 + dv1, [11, 10, 9, 8, 7, 6, 5, 4, 3, 2]);
    const dv22 = (0, utils_12.sumToDV)(sum2);
    return `${dv1}${dv22}`;
  };
  exports.dv = dv2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "000.000.000-00");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const num = (0, utils_12.fakeNumber)(9, true);
    const cpf2 = `${num}${(0, exports.dv)(num)}`;
    if (withMask)
      return (0, exports.mask)(cpf2);
    return cpf2;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    const cpf2 = (0, utils_12.clearValue)(value, 11, {
      fillZerosAtLeft: true,
      rejectEmpty: true,
      rejectHigherLength: true,
      rejectEqualSequence: true
    });
    if ((0, exports.dv)(cpf2) !== cpf2.substring(9, 11)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  exports.default = exports.validate;
})(cpf);
var judicialProcess = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  exports._getSubCourt = _getSubCourt;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const judicialProcess2 = (0, utils_12.clearValue)(value, 18, { trimAtRight: true, rejectEmpty: true });
    const num = judicialProcess2.substring(0, 7);
    const yearAndCourt = judicialProcess2.substring(7, 14);
    const origin = judicialProcess2.substring(14, 18);
    return String(98 - Number(`${Number(`${Number(num) % 97}${yearAndCourt}`) % 97}${origin}00`) % 97).padStart(2, "0");
  };
  exports.dv = dv2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "0000000-00.0000.0.00.0000");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const num = (0, utils_12.fakeNumber)(7, true);
    const year = (/* @__PURE__ */ new Date()).getFullYear() - +(0, utils_12.fakeNumber)(1);
    let courte1 = (0, utils_12.fakeNumber)(1, true);
    courte1 = courte1 === "0" ? "1" : courte1;
    const courte2 = _getSubCourt();
    const courte = `${courte1}${courte2}`;
    const origin = (0, utils_12.fakeNumber)(4, true);
    const judicialProcess2 = `${num}${year}${courte}${origin}`;
    const digits = (0, exports.dv)(judicialProcess2);
    const finalNumber = (0, utils_12.insertAtPosition)(judicialProcess2, digits, 7);
    if (withMask)
      return (0, exports.mask)(finalNumber);
    return finalNumber;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    const judicialProcess2 = (0, utils_12.clearValue)(value, 20, {
      fillZerosAtLeft: true,
      rejectEmpty: true,
      rejectHigherLength: true
    });
    const processWithoutDV = (0, utils_12.removeFromPosition)(judicialProcess2, 7, 9);
    if (processWithoutDV.substring(11, 12) === "0") {
      throw new Error('Código do Órgão Judiciário não pode ser "0"');
    }
    if ((0, exports.dv)(processWithoutDV) !== judicialProcess2.substring(7, 9)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  function _getSubCourt(courte = void 0) {
    courte = courte !== null && courte !== void 0 ? courte : (0, utils_12.fakeNumber)(2, true).toString();
    return +courte === 0 ? "01" : courte;
  }
  exports.default = exports.validate;
})(judicialProcess);
var nup17 = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const nup = (0, utils_12.clearValue)(value, 15, { rejectEmpty: true, trimAtRight: true });
    const nupReverse = nup.split("").reverse().join("");
    const sum1 = (0, utils_12.sumElementsByMultipliers)(nupReverse, [...Array(15)].map((_, i) => i + 2));
    const dv1 = _specificSumToDV(sum1);
    const sum2 = (0, utils_12.sumElementsByMultipliers)(dv1 + nupReverse, [...Array(16)].map((_, i) => i + 2));
    const dv22 = _specificSumToDV(sum2);
    return `${dv1}${dv22}`;
  };
  exports.dv = dv2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "00000.000000/0000-00");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const num = (0, utils_12.fakeNumber)(15, true);
    const nup = `${num}${(0, exports.dv)(String(num))}`;
    if (withMask)
      return (0, exports.mask)(nup);
    return nup;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    const nup = (0, utils_12.clearValue)(value, 17, {
      rejectEmpty: true,
      rejectHigherLength: true
    });
    if ((0, exports.dv)(nup) !== nup.substring(15, 17)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  exports.default = exports.validate;
  function _specificSumToDV(sum) {
    const rest = 11 - sum % 11;
    const exceptions = [
      { rest: 11, dv: 1 },
      { rest: 10, dv: 0 }
    ];
    const inExceptions = exceptions.find((item) => item.rest === rest);
    return !inExceptions ? rest : inExceptions.dv;
  }
})(nup17);
var pisPasep = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const pis = (0, utils_12.clearValue)(value, 10, {
      trimAtRight: true,
      rejectEmpty: true
    });
    const sum = (0, utils_12.sumElementsByMultipliers)(pis, [3, 2, 9, 8, 7, 6, 5, 4, 3, 2]);
    return String((0, utils_12.sumToDV)(sum));
  };
  exports.dv = dv2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "000.00000.00-0");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const num = (0, utils_12.fakeNumber)(10, true);
    const pis = `${num}${(0, exports.dv)(num)}`;
    if (withMask)
      return (0, exports.mask)(pis);
    return pis;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    const pis = (0, utils_12.clearValue)(value, 11, {
      fillZerosAtLeft: true,
      rejectEmpty: true,
      rejectHigherLength: true,
      rejectEqualSequence: true
    });
    if ((0, exports.dv)(pis) !== pis.substring(10, 11)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  exports.default = exports.validate;
})(pisPasep);
var postalCode = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    if (!value)
      throw ValidationBRError_12.default.EMPTY_VALUE;
    const postalCode2 = String(value).replace(/[^0-9]+/gi, "").padStart(8, "0").substring(0, 8);
    const sum = (0, utils_12.sumElementsByMultipliers)(postalCode2, [8, 6, 4, 2, 3, 5, 9, 7]);
    const rest = sum % 11;
    const specificities = [
      { rest: 0, dv: 5 },
      { rest: 1, dv: 0 }
    ];
    const specifity = specificities.find((item) => item.rest === rest);
    const DV = specifity ? specifity.dv : 11 - rest;
    return String(DV);
  };
  exports.dv = dv2;
  const mask2 = (value) => String(value).toLocaleUpperCase();
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const num = (0, utils_12.fakeNumber)(8, true);
    const postalCode2 = `${(0, utils_12.randomLetter)()}${(0, utils_12.randomLetter)()}${num}${(0, exports.dv)(num)}BR`;
    if (withMask)
      return (0, exports.mask)(postalCode2);
    return postalCode2;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    if (!/^[a-z]{2}([\d]{9})[a-z]{2}$/gi.test(String(value))) {
      throw new Error('O número não está no formato "XX000000000XX"');
    }
    const postalCode2 = (0, utils_12.clearValue)(value.substring(2, 11), 9);
    if ((0, exports.dv)(value.substring(2, 11)) !== postalCode2.substring(8, 9)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  exports.default = exports.validate;
})(postalCode);
var renavam = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const renavam2 = (0, utils_12.clearValue)(value, 10, {
      fillZerosAtLeft: true,
      trimAtRight: true,
      rejectEmpty: true
    });
    const sum1 = (0, utils_12.sumElementsByMultipliers)(renavam2, [3, 2, 9, 8, 7, 6, 5, 4, 3, 2]) * 10;
    const dv1 = sum1 % 11 >= 10 ? 0 : sum1 % 11;
    return `${dv1}`;
  };
  exports.dv = dv2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "0000000000-0");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const value = (0, utils_12.fakeNumber)(10, true);
    const renavam2 = `${value}${(0, exports.dv)(value)}`;
    if (withMask)
      return (0, exports.mask)(renavam2);
    return renavam2;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    const renavam2 = (0, utils_12.clearValue)(value, 11, {
      fillZerosAtLeft: true,
      rejectEmpty: true,
      rejectHigherLength: true,
      rejectEqualSequence: true
    });
    if ((0, exports.dv)(renavam2) !== renavam2.substring(10, 11)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  exports.default = exports.validate;
})(renavam);
var tituloEleitor = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validate = exports.validateOrFail = exports.fake = exports.mask = exports.dv = void 0;
  const ValidationBRError_12 = __importDefault2(ValidationBRError$1);
  const utils_12 = utils;
  const dv2 = (value) => {
    const titulo = (0, utils_12.clearValue)(value, 10, {
      fillZerosAtLeft: true,
      trimAtRight: true,
      rejectEmpty: true
    });
    const sum1 = (0, utils_12.sumElementsByMultipliers)(titulo.substring(0, 8), [2, 3, 4, 5, 6, 7, 8, 9]);
    const dv1 = sum1 % 11 >= 10 ? 0 : sum1 % 11;
    const sum2 = (0, utils_12.sumElementsByMultipliers)(titulo.substring(8, 10) + dv1, [7, 8, 9]);
    const dv22 = sum2 % 11 >= 10 ? 0 : sum2 % 11;
    return `${dv1}${dv22}`;
  };
  exports.dv = dv2;
  const mask2 = (value) => (0, utils_12.applyMask)(value, "0000.0000.0000");
  exports.mask = mask2;
  const fake2 = (withMask = false) => {
    const num = (0, utils_12.fakeNumber)(8, true);
    const uf = (Math.random() * 27 + 1).toFixed(0).padStart(2, "0");
    const titulo = `${num}${uf}${(0, exports.dv)(num + uf)}`;
    if (withMask)
      return (0, exports.mask)(titulo);
    return titulo;
  };
  exports.fake = fake2;
  const validateOrFail2 = (value) => {
    const titulo = (0, utils_12.clearValue)(value, 12, {
      fillZerosAtLeft: true,
      rejectEmpty: true,
      rejectHigherLength: true,
      rejectEqualSequence: true
    });
    if ((0, exports.dv)(titulo) !== titulo.substring(10, 12)) {
      throw ValidationBRError_12.default.INVALID_DV;
    }
    return true;
  };
  exports.validateOrFail = validateOrFail2;
  const validate2 = (value) => {
    try {
      return (0, exports.validateOrFail)(value);
    } catch (error) {
      return false;
    }
  };
  exports.validate = validate2;
  exports.default = exports.validate;
})(tituloEleitor);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNUP17 = exports.isTituloEleitor = exports.isRenavam = exports.isPostalCode = exports.isPIS = exports.isJudicialProcess = exports.isCPF = exports.isCNPJ = exports.isCNH = void 0;
  const cnh_1 = cnh;
  const cnpj_1 = cnpj;
  const cpf_1 = cpf;
  const judicialProcess_1 = judicialProcess;
  const nup17_1 = nup17;
  const pisPasep_1 = pisPasep;
  const postalCode_1 = postalCode;
  const renavam_1 = renavam;
  const tituloEleitor_1 = tituloEleitor;
  const isCNH = (value) => (0, cnh_1.validate)(value);
  exports.isCNH = isCNH;
  const isCNPJ = (value) => (0, cnpj_1.validate)(value);
  exports.isCNPJ = isCNPJ;
  const isCPF = (value) => (0, cpf_1.validate)(value);
  exports.isCPF = isCPF;
  const isJudicialProcess = (value) => (0, judicialProcess_1.validate)(value);
  exports.isJudicialProcess = isJudicialProcess;
  const isPIS = (value) => (0, pisPasep_1.validate)(value);
  exports.isPIS = isPIS;
  const isPostalCode = (value) => (0, postalCode_1.validate)(value);
  exports.isPostalCode = isPostalCode;
  const isRenavam = (value) => (0, renavam_1.validate)(value);
  exports.isRenavam = isRenavam;
  const isTituloEleitor = (value) => (0, tituloEleitor_1.validate)(value);
  exports.isTituloEleitor = isTituloEleitor;
  const isNUP17 = (value) => (0, nup17_1.validate)(value);
  exports.isNUP17 = isNUP17;
  exports.default = {
    isCNH: exports.isCNH,
    isCNPJ: exports.isCNPJ,
    isCPF: exports.isCPF,
    isJudicialProcess: exports.isJudicialProcess,
    isPIS: exports.isPIS,
    isPostalCode: exports.isPostalCode,
    isRenavam: exports.isRenavam,
    isTituloEleitor: exports.isTituloEleitor,
    isNUP17: exports.isNUP17
  };
})(dist);
const baseTextInputStyles = "wc-block-gateway-input paghiper_tax_id p-Input-input Input p-Input-input--textRight";
const InlineTaxIdField = ({
  inputErrorComponent: ValidationInputError2,
  onChange,
  gatewayName
}) => {
  const [isEmpty, setIsEmpty] = reactExports.useState(true);
  const [isInvalid, setIsInvalid] = reactExports.useState(false);
  const [isComplete, setIsComplete] = reactExports.useState(false);
  const [fieldLabel, setFieldLabel] = reactExports.useState(__$1("CPF do Pagador", "woo-boleto-paghiper"));
  const [fieldInput, setFieldInput] = reactExports.useState("");
  const { isActive, isFocus, onActive, error, setError } = useElementOptions({
    hideIcon: true
  });
  const errorCallback = (event) => {
    if (event.error) {
      setError(event.error.message);
    } else {
      setError("");
    }
    setIsEmpty(event.empty);
    onChange(event);
    if (!event.target.value) {
      setIsEmpty(true);
    }
  };
  reactExports.useEffect(() => {
    if (fieldInput.replace(/\D/g, "").length > 11) {
      setFieldLabel(__$1("CNPJ do Pagador", "woo-boleto-paghiper"));
    } else {
      setFieldLabel(__$1("CPF do Pagador", "woo-boleto-paghiper"));
    }
    if (!isEmpty) {
      if (!isFocus) {
        if (fieldInput.replace(/\D/g, "").length > 11 && fieldInput.replace(/\D/g, "").length < 14) {
          setError(__$1("O número do seu CNPJ está incompleto.", "woo-boleto-paghiper"));
          setIsInvalid(true);
        } else if (fieldInput.replace(/\D/g, "").length < 11) {
          setError(__$1("O número do seu CPF está incompleto.", "woo-boleto-paghiper"));
          setIsInvalid(true);
        }
      } else {
        if (fieldInput.replace(/\D/g, "").length == 11) {
          if (!dist.isCPF(fieldInput)) {
            setError(__$1("O número do seu CPF está correto.", "woo-boleto-paghiper"));
            setIsInvalid(true);
          } else {
            setIsComplete(true);
          }
        } else if (fieldInput.replace(/\D/g, "").length == 14) {
          if (!dist.isCNPJ(fieldInput)) {
            setError(__$1("O número do seu CNPJ não está correto.", "woo-boleto-paghiper"));
            setIsInvalid(true);
          } else {
            setIsComplete(true);
          }
        }
      }
    } else {
      setIsInvalid(false);
      setIsComplete(false);
    }
  }, [fieldInput, isFocus]);
  reactExports.useEffect(() => {
    setIsInvalid(false);
    setIsComplete(false);
    setError("");
  }, [fieldInput]);
  const taxIdMaskBehavior = (val, e) => {
    return val.replace(/\D/g, "").length > 11 ? "00.000.000/0000-00" : "000.000.000-009";
  };
  reactExports.useEffect(() => {
    if (typeof jQuery(".paghiper_tax_id").mask === "function") {
      jQuery(".paghiper_tax_id").mask(taxIdMaskBehavior, {
        onKeyPress: function(val, e, field, options2) {
          field.mask(taxIdMaskBehavior.apply({}, arguments), options2);
        }
      });
    } else {
      console.log("Paghiper block failed to initialize TaxID mask");
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wc-block-components-form", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wc-block-gateway-container wc-block-components-text-input wc-inline-tax-id-element paghiper-taxid-fieldset" + (isActive || !isEmpty ? " is-active" : ""), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "text",
        id: "wc-paghiper-inline-tax-id-element",
        name: "_" + gatewayName + "_cpf_cnpj",
        className: baseTextInputStyles + (isEmpty ? " empty Input--empty" : "") + (isInvalid ? " invalid" : "") + (isComplete ? " valid" : ""),
        onBlur: () => onActive(isEmpty, false),
        onFocus: () => onActive(isEmpty, true),
        onChange: errorCallback,
        onInput: (e) => setFieldInput(e.target.value),
        "aria-label": fieldLabel,
        required: true,
        title: true
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "wc-paghiper-inline-tax-id-element", children: fieldLabel }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ValidationInputError2, { errorMessage: error })
  ] }) }) });
};
const { __ } = window.wp.i18n;
const { useState, useEffect } = window.wp.element;
const { decodeEntities } = window.wp.htmlEntities;
const { registerPaymentMethod } = window.wc.wcBlocksRegistry;
const { ValidationInputError } = window.wc.blocksCheckout;
const { getSetting } = window.wc.wcSettings;
const pixSettings = getSetting("paghiper_pix_data", {});
const defaultPixLabel = __("PIX Paghiper", "woo-boleto-paghiper");
const label = decodeEntities(pixSettings.title) || defaultPixLabel;
const Content = (props) => {
  if (typeof wc === "undefined" || !wc.wcBlocksRegistry) {
    console.error("WooCommerce Blocks registry not found. Make sure WooCommerce Blocks is active and loaded.");
    return;
  }
  if (typeof wc === "undefined" || !wc.blocksCheckout) {
    console.error("WooCommerce Blocks Checkout not found. Make sure WooCommerce Blocks is active and loaded.");
    return;
  }
  const { eventRegistration, emitResponse } = props;
  const { onPaymentSetup } = eventRegistration;
  const [taxID, setTaxID] = useState("");
  const [payerName, setPayerName] = useState("");
  useEffect(() => {
    const unsubscribe = onPaymentSetup(async () => {
      const paghiperTaxId = taxID;
      const paghiperTaxIdIsValid = !!paghiperTaxId.length;
      const paghiperTaxIdFieldName = "_" + props.gatewayName + "_cpf_cnpj";
      if (paghiperTaxIdIsValid) {
        return {
          type: emitResponse.responseTypes.SUCCESS,
          meta: {
            paymentMethodData: {
              [paghiperTaxIdFieldName]: paghiperTaxId
            }
          }
        };
      }
      return {
        type: emitResponse.responseTypes.ERROR,
        message: "There was an error"
      };
    });
    return () => {
      unsubscribe();
    };
  }, [
    taxID,
    emitResponse.responseTypes.ERROR,
    emitResponse.responseTypes.SUCCESS,
    onPaymentSetup
  ]);
  const onChange = (paymentEvent) => {
    if (paymentEvent.error) {
      console.log("Paghiper: Payment Error");
    }
    setTaxID(paymentEvent.target.value.replace(/\D/g, ""));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: decodeEntities(props.gatewayDescription || "") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InlineTaxIdField,
      {
        gatewayName: props.gatewayName,
        onChange,
        inputErrorComponent: ValidationInputError
      }
    )
  ] });
};
const Label = (props) => {
  const { PaymentMethodLabel } = props.components;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethodLabel, { text: label });
};
const PaghiperPix = {
  name: "paghiper_pix",
  label: /* @__PURE__ */ jsxRuntimeExports.jsx(Label, {}),
  content: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { gatewayName: "paghiper_pix", gatewayDescription: pixSettings.description }),
  edit: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { gatewayName: "paghiper_pix", gatewayDescription: pixSettings.description }),
  canMakePayment: () => true,
  ariaLabel: label,
  paymentMethodId: "paghiper_pix",
  supports: {
    features: pixSettings.supports
  }
};
const billetSettings = getSetting("paghiper_billet_data", {});
const defaultBilletLabel = __("Boleto Paghiper", "woo-boleto-paghiper");
const billetLabel = decodeEntities(billetSettings.title) || defaultBilletLabel;
const BilletLabel = (props) => {
  const { PaymentMethodLabel } = props.components;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethodLabel, { text: billetLabel });
};
const PaghiperBillet = {
  name: "paghiper_billet",
  label: /* @__PURE__ */ jsxRuntimeExports.jsx(BilletLabel, {}),
  content: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { gatewayName: "paghiper_billet", gatewayDescription: billetSettings.description }),
  edit: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { gatewayName: "paghiper_billet", gatewayDescription: billetSettings.description }),
  canMakePayment: () => true,
  ariaLabel: billetLabel,
  supports: {
    features: billetSettings.supports
  }
};
if (typeof window.wc.wcBlocksRegistry !== "undefined") {
  registerPaymentMethod(PaghiperPix);
  registerPaymentMethod(PaghiperBillet);
}
//# sourceMappingURL=blocks.min.js.map
})();